[{"content":"1 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题） 1 #define SEC_YEAR (365*24*60*60)UL 考察点：\n#define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）\n懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。\n意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数\n如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。\n2 写一个\u0026quot;标准\u0026quot;宏MIN ，这个宏输入两个参数并返回较小的一个。 1 #define MIN(a,b) ((a)\u0026lt;=(b)?(a):(b)) 考察点：\n标识#define在宏中应用的基本知识。这是很重要的。因为在 嵌入(inline)操作符 变为标准C的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。\n懂得在宏中小心地把参数用括号括起来\n我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？\n1 least = MIN(*p++, b); 宏定义的作用结果MIN(*p++,b) ((*p++)\u0026lt;(b)?(*p++),b) 指针p会做两次自增操作\n如何消除宏的副作用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;stdio.h\u0026gt; #define min_i(x,y) ((x)\u0026lt;=(y)?(x):(y)) //（1） #define min_t(type,x,y) ({type _x = x;\\ //（2） type _y = y;\\ _x\u0026lt;_y?_x:_y;\\ }) #define min(x,y) {const typeof(x) _x = (x);\\ //（3） const typeof(y) _y = (y);\\ (void)(\u0026amp;_x=\u0026amp;_y);\\ //（4） _x\u0026lt;_y?_x:_y;\\ }) int main() { int a = 10; int b = 20; printf(\u0026#34;min_i(a++,b++)=%d\\n\u0026#34;,min_i(a++,b++)); //11 printf(\u0026#34;a=%d\\n\u0026#34;,a); //12 printf(\u0026#34;b=%d\\n\u0026#34;,b); //21 a=10; b=20; printf(\u0026#34;min_t(int,a++,b++)=%d\\n\u0026#34;,min_t(int,a++,b++)); //10 printf(\u0026#34;a=%d\\n\u0026#34;,a); //11 printf(\u0026#34;b=%d\\n\u0026#34;,b); //21 a=10; b=20; printf(\u0026#34;min(a++,b++)=%d\\n\u0026#34;,min(a++,b++)); //10 printf(\u0026#34;a=%d\\n\u0026#34;,a); //11 printf(\u0026#34;b=%d\\n\u0026#34;,b); //21 } 这个定义计算x和y分别两次（x和y中的小者被计算两次)，当参数由副作用时，将产生不正确的结果\n使用语句表达式只计算参数一次，避免了可能的错误，语句表达式通常用于宏定义 typeof(x)表示x的值类型 检查参数x和y的类型是否相同(如果x和y的类型不同编译器将会发出warning，并不影响后面语句的运行\n3 预处理器标识#error的目的是什么？ 编译程序时，只要遇到 #error 就会跳出一个编译错误，既然是编译错误，要它干嘛呢？其目的就是保证程序是按照你所设想的那样进行编译的。\n下面举个例子：程序中往往有很多的预处理指令\n1 2 3 4 5 #ifdef XXX ... #else ... #endif 当程序比较大时，往往有些宏定义是在外部指定的（如makefile），或是在系统头文件中指定的，当你不太确定当前是否定义了 XXX 时，就可以改成如下这样进行编译：\n1 2 3 4 5 6 #ifdef XXX ... #error \u0026#34;XXX has been defined\u0026#34; #else #endif 这样,如果编译时出现错误,输出了XXX has been defined,表明宏XXX已经被定义了。\n4 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？ 1 2 3 4 5 6 7 while(1) {} for(;;) {} loop:... goto loop; 5 用变量a给出下面的定义 a) 一个整型数（An integer） b)一个指向整型数的指针（ A pointer to an integer） c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege） d)一个有10个整型数的数组（ An array of 10 integers） e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers） f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers） g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer） h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数 （ An array of ten pointers to functions that take an integer argument and return an integer ）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a)int a; b)int *a; c)int **a; d)int a[10] e)int *a[10] f)int (*a)[10] g)int (*a)(int a) h)int (*a[10])(int) 6 关键字static的作用是什么？ 在C语言中，关键字static有三个明显的作用：\n第一、在修饰变量的时候，static修饰的静态局部变量只执行一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。 第二、static修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是extern外部声明也不可以。 第三、static修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。Static修饰的局部变量存放在全局数据区的静态变量区。初始化的时候自动初始化为0； （1）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用static修饰 （2）考虑到数据安全性（当程想要使用全局变量的时候应该先考虑使用static） 在C++中static关键字除了具有C中的作用还有在类中的使用在类中，static可以用来修饰静态数据成员和静态成员方法静态数据成员\n（1）静态数据成员可以实现多个对象之间的数据共享，它是类的所有对象的共享成员，它在内存中只占一份空间，如果改变它的值，则各对象中这个数据成员的值都被改变。 （2）静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义对象，也会为静态数据成员分配空间。 （3）静态数据成员可以被初始化，但是只能在类体外进行初始化，若为对静态数据成员赋初值，则编译器会自动为其初始化为0 （4）静态数据成员既可以通过对象名引用，也可以通过类名引用。 静态成员函数\n（1）静态成员函数和静态数据成员一样，他们都属于类的静态成员，而不是对象成员。 （2）非静态成员函数有this指针，而静态成员函数没有this指针。 （3）静态成员函数主要用来方位静态数据成员而不能访问非静态成员。\n7 关键字const有什么含意？ 只要一个变量前用const来修饰，就意味着该变量里的数据只能被访问，而不能被修改，也就是意味着const“只读”（readonly）。\n规则：const离谁近，谁就不能被修改；\nconst修饰一个变量时，一定要给这个变量初始化，若不初始化，在后面也不能初始化。\nconst作用：\n1：可以用来定义常量，修饰函数参数，修饰函数返回值 ，且被const修饰的东西，都受到强制保护，可以预防其它代码无意识的进行修改，从而提高了程序的健壮性（是指系统对于规范要求以外的输入能够判断这个输入不符合规范要求，并能有合理的处理方式。ps：即所谓高手写的程序不容易死）； 2：使编译器保护那些不希望被修改的参数，防止无意代码的修改，减少bug； 3：给读代码的人传递有用的信息，声明一个参数，是为了告诉用户这个参数的应用目的； const优点：\n1：编译器可以对const进行类型安全检查（所谓的类型安全检查，能将程序集间彼此隔离开来，这种隔离能确保程序集彼此间不会产生负面影响，提高程序的可读性）； 2：有些集成化的调试工具可以对const常量进行调试，使编译器对处理内容有了更多的了解，消除了一些隐患。eg：void hanshu（const int i）{\u0026hellip;\u0026hellip;.} 编译器就会知道i是一个不允许被修改的常量 3：可以节省空间，避免不必要的内存分配，因为编译器通常不为const常量分配内存空间，而是将它保存在符号表中，这样就没有了存储于读内存的操作，使效率也得以提高； 4：可以很方便的进行参数的修改和调整，同时避免意义模糊的数字出现\n8 关键字volatile有什么含意？并给出三个不同的例子。 一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：\n1：并行设备的硬件寄存器（如：状态寄存器） 2：一个中断服务子程序中会访问到的非自动变量(Non-automatic variables) 3：多线程应用中被几个任务共享的变量\n9 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。 考察点：\n1：不知道如何下手。该被面者从没做过任何嵌入式系统的工作。\n2：用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可 重用的。\n最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方 式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。\n3：用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：\n1 2 3 4 5 6 7 8 9 10 11 #define BIT3 (0x1 \u0026lt;\u0026lt; 3) static int a; void set_bit3(void) { a |= BIT3; } void clear_bit3(void) { a \u0026amp;= ~BIT3; } 10 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。 考察点：\n这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。\n1 2 3 4 5 6 7 int *ptr; ptr = (int *)0x67a9; *ptr = 0xaa55; ...... *(int *const)(0x67a9) = 0xaa66; 11 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。 1 2 3 4 5 6 __interrupt double compute_area (double radius) { double area = PI * radius * radius; printf(\u0026#34;\\nArea = %f\u0026#34;, area); return area; } 考察点：\n1：ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。 2：ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。 3：在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。 4：与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。\n12 下面的代码输出是什么，为什么？ 1 2 3 4 5 6 void foo(void) { unsigned int a = 6; int b = -20; (a+b \u0026gt; 6) ? puts(\u0026#34;\u0026gt; 6\u0026#34;) : puts(\u0026#34;\u0026lt;= 6\u0026#34;); } 考察点：\n这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。\n不管如何，这无符号整型问题的答案是输出是 \u0026ldquo;\u0026gt;6\u0026rdquo;。原因 是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。\n因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。\n如果你答错了这个问题，你也就到了得不到这份工作的边缘。\n13 评价下面的代码片断： 1 2 3 unsigned int zero = 0; unsigned int compzero = 0xFFFF; /*1\u0026#39;s complement of zero */ 考察点：\n对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：\n1 unsigned int compzero = ~0; 这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件\n作为一个无法避免的烦恼。\n到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。\n但如果显然应试者做得不错，那么我就 扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如 何，你就当是这个娱乐吧\u0026hellip;\n14 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。 那么嵌入式系统中，动态分配内存可能发生的问题是什么？\n这 里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么 一个小节目：下面的代码片段的输出是什么，为什么？\n1 2 3 4 5 char *ptr; if ((ptr = (char *)malloc(0)) == NULL) puts(\u0026#34;Got a null pointer\u0026#34;); else puts(\u0026#34;Got a valid pointer\u0026#34;); 这 是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输 出是\u0026quot;Got a valid pointer\u0026quot;。\n我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。\n得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。\n15 Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子： 1 2 #define dPS struct s * typedef struct s * tPS; 以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？\n考察点：\n这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：\n1 2 dPS p1,p2; tPS p3,p4; 第一个扩展为\n1 struct s * p1, p2; 上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。\n16 C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？ 1 2 int a = 5, b = 7, c; c = a+++b; 考察点：\n这个问题将作为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：\n1 c = a++ + b; 因此, 这段代码持行后a = 6, b = 7, c = 12。\n如果你知道答案，或猜出正确答案，做得好。 如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。\n原文：https://www.cnblogs.com/hjhgogo/p/9953506.html\n文章来源于网络，版权归原作者所有，如有侵权，请联系删除。\n","date":"2022-08-01T18:55:22+08:00","image":"https://img.gejiba.com/images/b129b387545aacfcae6819fc42aca17a.png","permalink":"https://www.stepbystep.cf/archives/c-problems/","title":"C语言经典问题"},{"content":" 用word打开要处理的文档 Ctrl+A 全选文档 Ctrl+H 打开替换窗口 点击左下角更多 确保“使用通配符”为勾选状态 查找框中输入[!^1-^127] (英文状态输入) 替换框为空白 点击“替换全部” ","date":"2022-03-22T17:20:12.875Z","image":"https://img.gejiba.com/images/24573291207ff1f08c2a9a343cfe7925.webp","permalink":"https://www.stepbystep.cf/archives/remove-chinese-character/","title":"如何批量去掉文档中的中文"},{"content":" 一、下载ISO镜像与工具 ISO镜像下载(archlinux-xxxx.xx.xx-x86_64.iso)\nrufus下载(rufus-x.xp.exe)\nihasher下载\n二、制作安装U盘 注意：制作的安装U盘将被格式化，即删除里面所有内容!\n如果询问是否允许更新、确认格式化U盘，点击yes即可\n三、预留分区 Windows+R输入diskmgmt.msc 四、选择UEFI模式并进入u盘安装系统 选择UEFI模式启动，不同电脑不太一样，请按照电脑说明书或上网搜索进行该步骤。\n更新系统时间 root@archiso ~ # timedatectl set-ntp true 分区 root@archiso ~ # fdisk -l 结果中以 rom、loop 或者 airoot 结尾的设备可以被忽略。\n对于一个选定的设备，以下分区是必须要有的：\n一个根分区（挂载在 根目录）/\n一个 EFI 系统分区\n请使用 fdisk 或 parted 修改分区表。例如：\nroot@archiso ~ # fdisk /dev/the_disk_to_be_partitioned（要被分区的磁盘） 挂载点 分区 分区类型 建议大小 /mnt/boot /dev/efi_system_partition（efi 系统分区） EFI 系统分区 至少 260 MiB /mnt /dev/root_partition（根分区） Linux x86-64 根目录 (/) 剩余空间 格式化分区 root@archiso ~ # mkfs.ext4 /dev/root_partition（根分区） root@archiso ~ # mkfs.fat -F 32 /dev/efi_system_partition 挂载分区 将根磁盘卷 挂载 到 /mnt，将efi系统卷挂载到/mnt/boot\nroot@archiso ~ # mkdir /mnt/boot root@archiso ~ # mount /dev/root_partition（根分区） /mnt root@archiso ~ # mount /dev/（efi系统分区） /mnt/boot 设置镜像源 root@archiso ~ # reflector --country China --age 12 --protocol https --sort rate --save /etc/pacman.d/mirrorlist 安装必需的软件包 root@archiso ~ # pacstrap /mnt base linux linux-firmware 配置系统 Fstab 用以下命令生成 fstab 文件 (用 -U 或 -L 选项设置UUID 或卷标)：\nroot@archiso ~ # genfstab -U /mnt \u003e\u003e /mnt/etc/fstab 强烈建议在执行完以上命令后，后检查一下生成的 /mnt/etc/fstab 文件是否正确。\nChroot Change root 到新安装的系统：\nroot@archiso ~ # arch-chroot /mnt [root@archiso /]# 时区 要设置时区：\n[root@archiso /]# ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime [root@archiso /]# hwclock --systohc 本地化 编辑 /etc/locale.gen，然后取消掉 en_US.UTF-8 UTF-8 和其他需要的 地区 前的注释（#）。\n[root@archiso /]# vim /etc/locale.gen [root@archiso /]# locale-gen [root@archiso /]# vim /etc/locale.conf LANG=en_US.UTF-8 网络配置 创建 hostname 文件:\n/etc/hostname\nmyhostname（主机名） 添加对应的信息到 hosts:\n[root@archiso /]# vim /etc/hosts 127.0.0.1\tlocalhost ::1\tlocalhost 127.0.1.1\tmyhostname.localdomain\tmyhostname # 主机名.本地域名 主机名 设置root密码 [root@archiso /]# passwd 安装引导、内核、联网相关软件包 [root@archiso /]# pacman -S grub efibootmgr intel-ucode os-prober wpa_supplicant dhcpcd 配置grub引导 [root@archiso /]# mkdir /boot/grub [root@archiso /]# grub-mkconfig \u003e /boot/grub/grub.cfg [root@archiso /]# grub-install --target=x86_64-efi --efi-directory=/boot [root@archiso /]# [root@archiso /]# 退出chroot [root@archiso /]# exit root@archiso ~ # umount -R /mnt root@archiso ~ # reboot [1]ArchWiki. Installation guide[EB/OL]. [2022-3-16]. https://wiki.archlinux.org/title/Installation_guide.\n","date":"2022-03-13T17:53:05Z","image":"https://img.gejiba.com/images/075c3114aaa8572c21a29560330cccca.webp","permalink":"https://www.stepbystep.cf/archives/archlinux/","title":"Archlinux安装指南"},{"content":"如果你已经学会了电脑的基本操作（如开关机，点击鼠标键盘\u0026hellip;）下一步，你应该学习的是电脑使用原则。\n总则 一、勇 有人说我天生会电脑，其实这是不对的。能会使用电脑，关键在于你对待电脑的态度。你需要把电脑当做一个玩具，而不是一个工具，你需要把系统和软件当做游戏。只要你不去乱动系统设置等危险地带，一般不会弄坏电脑。所以说：一定要勇！勇敢地去尝试，积累经验。不要怕这怕那。你畏缩不前，就永远不能看到胜利的彼岸。\n二、查 有不会的问题，上必应搜一搜。不要再用百度了，都是广告和无用的杂牌信息。记住，先查再问。\n三、记 当你学会了一个技能，要记住它。\n四、练 勤加练习，多尝试，多总结\n五、悟 永远不要指望最详细的教程，你需要自己去领悟，去探索未知世界。\n大忌 把文件放到桌面上 把软件安装到C盘 不加分辨地从网上下载软件 用中文命名软件安装目录和系统用户名 安装软件 困扰很多电脑初学者的第一个问题就是安装软件。 打开pc.qq.com，在右上方搜索栏搜索软件名称，然后在结果里找到你想要的软件，点击右侧绿色按钮的小箭头然后点击普通下载。打开下载后的安装包，95%的软件都在安装时可以自定义安装位置。在D盘新建一个文件夹，命名与软件名称相同（英文，首字母大写），如果软件名称为中文，请用首字母大写的拼音全拼，无空格（如暴风影音：Baofeng），不要添加任何标点符号。选择该目录安装。安装时要注意细节选项。\n卸载软件 第一次准备工作 点击下面链接下载Geek Uninstaller 点我下载 保存在D盘新建文件夹（命名为Geek）\n卸载方法 打开geek，找到要卸载的软件，右键点击卸载。在弹出的卸载窗口按照提示卸载。然后返回geek窗口点击删除。然后进度条完成后关闭geek即可。\n","date":"2022-03-06T06:28:31.858Z","image":"https://img.gejiba.com/images/dc28dd597dffccfbf3d871509da52d31.webp","permalink":"https://www.stepbystep.cf/archives/computer-tutorial/","title":"电脑小白入门手册📔"},{"content":"我们在平时预览二次元美图的时候经常会遇到图片不够清晰的问题，图片质量大打折扣。有人可能知道waifu2x这个工具，但今天在这里给大家介绍一个比waifu2x好用很多倍的神器——Real-CUGAN。 GitHub链接如下：https://github.com/fumiama/Real-CUGAN\n效果对比 原始图片waifu2xReal-CUGAN 一、安装Python 二、安装lib组件库 1 2 3 4 pip3 install torch pip3 install numpy pip3 install opencv-python pip3 install moviepy 三、建立工作目录并命名文件 建立文件夹及文件\n1 2 git clone https://hub.fastgit.xyz/fumiama/Real-CUGAN-Server.git cd Real-CUGAN-Server 替换input_dir1文件夹里的输入图片文件。\n四、调用命令处理图片 1 python3 upcunet_v3.py 输出图片在opt-dir-all-test文件夹中。\n","date":"2022-02-21T13:06:31.541Z","image":"https://img.gejiba.com/images/74623b89a8bda64c563f3064c421788b.webp","permalink":"https://www.stepbystep.cf/archives/real-cugan/","title":"让你的二次元美图更清晰"},{"content":"一、下载文件并校验文件完整性 点击下载新版Powershell(PowerShell-x.x.x-win-x64.msi)\n点击下载Git(Git-x.xx.x-64-bit.exe)\n点击下载oh-my-posh(install-amd64.exe)\n点击下载Checksum\n二、安装Git 三、安装Nerd Font字体 推荐JetBrainsMono 点击下载 下载解压后选中全部ttf文件，右键，安装\n四、安装Windows Terminal Preview Windows 应用商店搜索Windows Terminal Preview，并安装。\n如果由于网络原因无法打开应用商店，可以点击此处选择Windows Terminal Preview，复制详情页地址，粘贴到该网站，选择Retail渠道，下载安装包(最后一个)。\n五、安装新版PowerShell 一路下一步即可，建议安装到D盘的Powershell文件夹。\n打开Windows Terminal Preview的设置，选择左侧Windows PowerShell，路径改为安装的刚刚安装的D盘中Powershell文件夹中pwsh.exe，并在最后加上 -nologo参数。\n1 D:\\PowerShell\\7\\pwsh.exe -nologo 六、安装oh-my-posh 在D盘新建目录oh-my-posh，将oh-my-posh安装至该目录。\n七、设置字体与配色方案 推荐Dracula 在设置中打开JSON文件，找到\u0026quot;schemes\u0026quot;，在中括号中添加（注意除了最后一个，每个大括号块后的逗号）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \u0026#34;name\u0026#34;: \u0026#34;Dracula\u0026#34;, \u0026#34;cursorColor\u0026#34;: \u0026#34;#F8F8F2\u0026#34;, \u0026#34;selectionBackground\u0026#34;: \u0026#34;#44475A\u0026#34;, \u0026#34;background\u0026#34;: \u0026#34;#282A36\u0026#34;, \u0026#34;foreground\u0026#34;: \u0026#34;#F8F8F2\u0026#34;, \u0026#34;black\u0026#34;: \u0026#34;#21222C\u0026#34;, \u0026#34;blue\u0026#34;: \u0026#34;#BD93F9\u0026#34;, \u0026#34;cyan\u0026#34;: \u0026#34;#8BE9FD\u0026#34;, \u0026#34;green\u0026#34;: \u0026#34;#50FA7B\u0026#34;, \u0026#34;purple\u0026#34;: \u0026#34;#FF79C6\u0026#34;, \u0026#34;red\u0026#34;: \u0026#34;#FF5555\u0026#34;, \u0026#34;white\u0026#34;: \u0026#34;#F8F8F2\u0026#34;, \u0026#34;yellow\u0026#34;: \u0026#34;#F1FA8C\u0026#34;, \u0026#34;brightBlack\u0026#34;: \u0026#34;#6272A4\u0026#34;, \u0026#34;brightBlue\u0026#34;: \u0026#34;#D6ACFF\u0026#34;, \u0026#34;brightCyan\u0026#34;: \u0026#34;#A4FFFF\u0026#34;, \u0026#34;brightGreen\u0026#34;: \u0026#34;#69FF94\u0026#34;, \u0026#34;brightPurple\u0026#34;: \u0026#34;#FF92DF\u0026#34;, \u0026#34;brightRed\u0026#34;: \u0026#34;#FF6E6E\u0026#34;, \u0026#34;brightWhite\u0026#34;: \u0026#34;#FFFFFF\u0026#34;, \u0026#34;brightYellow\u0026#34;: \u0026#34;#FFFFA5\u0026#34; } 八、修改终端配置 设置 PowerShell 的初始化文件\n1 2 if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } notepad $PROFILE 粘贴以下内容进 profile 文件\n1 2 clear oh-my-posh --init --shell pwsh --config D:/oh-my-posh/themes/ys.omp.json | Invoke-Expression 主题预览： ","date":"2022-02-21T12:14:24.657Z","image":"https://img.gejiba.com/images/565ad253511245591b93e2d79ec3c6f3.webp","permalink":"https://www.stepbystep.cf/archives/beautify-windows-terminal/","title":"极致美化windows终端"}]